<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  
  <title>Analisi statistiche - SuperEnalotto Control Chaos</title>
  <meta name="description" content="Analisi statistiche SuperEnalotto: frequenze, ritardi, co-occorrenze, trend temporali e limiti interpretativi.">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@600;700&family=Fredoka:wght@600;700&display=swap">
<script src="../../assets/js/ga4.js" defer></script>
<link rel="stylesheet" href="../../assets/css/tailwind.generated.css">
<link rel="stylesheet" href="../../assets/css/main.css">
<link rel="stylesheet" href="../../assets/css/header.css">
  <link rel="stylesheet" href="../../assets/css/ads.css">
  <style>
    .tabs-shell {
      margin-top: 0.8rem;
      --active-notch-left: 0px;
      --active-notch-width: 0px;
    }
    .folder-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      padding-left: 0.65rem;
      margin-bottom: -1px;
      position: relative;
      overflow: visible;
    }
    .tab-btn {
      border: 1px solid rgba(255, 255, 255, 0.24);
      border-bottom: none;
      background:
        linear-gradient(175deg, rgba(255, 255, 255, 0.22), rgba(255, 255, 255, 0.06) 56%, rgba(10, 14, 26, 0.7)),
        linear-gradient(145deg, rgba(28, 36, 70, 0.5), rgba(10, 14, 26, 0.44));
      color: #cfd8ef;
      border-radius: 0.6rem 0.6rem 0 0;
      padding: 0.36rem 0.86rem 0.42rem;
      font-size: 0.66rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-weight: 700;
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.28),
        inset 0 -8px 14px rgba(7, 10, 20, 0.22);
      transition: background 160ms ease, border-color 160ms ease, color 160ms ease, box-shadow 160ms ease, transform 160ms ease;
      position: relative;
      z-index: 2;
    }
    .tab-btn.is-active {
      border-color: rgba(255, 217, 102, 0.88);
      background:
        linear-gradient(180deg, rgba(255, 232, 173, 0.36), rgba(255, 217, 102, 0.16)),
        linear-gradient(145deg, rgba(28, 36, 70, 0.54), rgba(10, 14, 26, 0.46));
      color: #ffe8a0;
      border-bottom-color: transparent;
      box-shadow: 0 0 14px rgba(255, 217, 102, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.44);
      transform: translateY(1px);
      z-index: 4;
    }
    .tab-btn.is-active::after {
      content: "";
      position: absolute;
      left: -10%;
      right: -10%;
      top: 100%;
      height: 18px;
      pointer-events: none;
      background: linear-gradient(
        180deg,
        rgba(255, 217, 102, 0.42) 0%,
        rgba(255, 217, 102, 0.2) 46%,
        rgba(255, 217, 102, 0) 100%
      );
      filter: blur(1.5px);
    }
    .tab-btn:not(.is-active) {
      transform: translateY(2px);
      opacity: 0.92;
      z-index: 1;
    }
    .tabs-sheet {
      margin-top: 0;
      border: 1px solid rgba(255, 217, 102, 0.52);
      border-top-color: rgba(255, 217, 102, 0.34);
      border-radius: 0.8rem 1rem 1rem 1rem;
      background:
        linear-gradient(165deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.04) 54%, rgba(10, 14, 26, 0.66)),
        linear-gradient(145deg, rgba(28, 36, 70, 0.46), rgba(10, 14, 26, 0.4));
      box-shadow:
        inset 0 1px 0 rgba(255, 241, 204, 0.22),
        inset 0 0 14px rgba(255, 217, 102, 0.1),
        inset 0 -12px 18px rgba(7, 10, 20, 0.22),
        0 0 16px rgba(255, 217, 102, 0.22),
        0 0 34px rgba(255, 217, 102, 0.12);
      padding: 1rem 1rem 1.2rem;
      position: relative;
      z-index: 2;
      overflow: hidden;
    }
    .tabs-sheet::before {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      top: -1px;
      height: 1px;
      background: rgba(255, 217, 102, 0.88);
      pointer-events: none;
      z-index: 3;
      border-top-left-radius: 0.8rem;
      border-top-right-radius: 1rem;
      mask-image:
        linear-gradient(
          90deg,
          #000 0 calc(var(--active-notch-left) - 0px),
          transparent calc(var(--active-notch-left) - 0px) calc(var(--active-notch-left) + var(--active-notch-width)),
          #000 calc(var(--active-notch-left) + var(--active-notch-width)) 100%
        );
      -webkit-mask-image:
        linear-gradient(
          90deg,
          #000 0 calc(var(--active-notch-left) - 0px),
          transparent calc(var(--active-notch-left) - 0px) calc(var(--active-notch-left) + var(--active-notch-width)),
          #000 calc(var(--active-notch-left) + var(--active-notch-width)) 100%
        );
    }
    .tab-panel {
      display: none;
    }
    .tab-panel.is-active {
      display: block;
    }
  </style>
</head>
<body class="min-h-screen bg-midnight text-white" id="top">
  <main class="content-fade mx-auto max-w-5xl content-width px-6 py-2">
    <div class="content-box">
      <header class="mt-6 space-y-3" data-page-kicker-wrap>
        <span class="text-xs uppercase tracking-[0.2em] text-ash" data-page-kicker>Analisi statistiche</span>
      </header>
      <section class="rounded-3xl bg-transparent p-0">

        <div class="tabs-shell mt-10 text-sm text-ash" data-tabs-root data-tab-panel-label="off">
          <div class="folder-tabs">
            <button class="tab-btn is-active" type="button" data-tab-target="fondamenti">Fondamenti</button>
            <button class="tab-btn" type="button" data-tab-target="frequenze">Frequenze</button>
            <button class="tab-btn" type="button" data-tab-target="ritardi">Ritardi</button>
            <button class="tab-btn" type="button" data-tab-target="cooccorrenze">Co-occorrenze</button>
            <button class="tab-btn" type="button" data-tab-target="stabilita">Stabilita e rischio</button>
            <button class="tab-btn" type="button" data-tab-target="ranking">Ranking</button>
          </div>

          <div class="tabs-sheet">
            <section class="tab-panel is-active space-y-4" data-tab-panel="fondamenti">

              <h2 class="text-lg font-semibold text-white">Cosa sono le statistiche e perche non vanno lette da sole</h2>
              <p>Le statistiche, dentro un progetto come questo, non sono risposte finali: sono strumenti di orientamento. Servono a trasformare migliaia di righe di storico in indicatori leggibili, comparabili e verificabili nel tempo. Il primo errore tipico e trattarle come oracoli. Il secondo errore, quasi opposto, e ignorarle perche "tanto e tutto casuale". La via utile sta in mezzo: usare le statistiche come metodo per dare forma all incertezza, non per cancellarla.</p>
              <p>Per capire perche non vanno mai lette singolarmente, immagina una sola metrica isolata: frequenza alta, ritardo estremo, coppia molto ricorrente. Ognuna puo sembrare forte, ma senza contesto rischia di essere solo un frammento. Una frequenza alta puo dipendere da una finestra breve. Un ritardo alto puo essere perfettamente compatibile con il normale comportamento di coda. Una co-occorrenza apparentemente brillante puo crollare appena allarghi il periodo o cambi filtro. Il dato singolo attrae, ma spesso semplifica troppo.</p>
              <p>La lettura robusta e multilivello. Prima si verifica la base: ampiezza campione, copertura temporale, regolarita dei dati. Poi si confrontano segnali diversi: frequenze, ritardi, relazioni tra numeri, stabilita inter-finestra. Infine si osserva la convergenza: due o tre indicatori indipendenti raccontano la stessa storia, oppure si contraddicono? E proprio la convergenza che aumenta la credibilita di una ipotesi. Se gli indicatori litigano, la prudenza e parte del metodo.</p>
              <p>Questo approccio aiuta anche a ridurre i bias cognitivi piu comuni. Il bias della recenza porta a sovrastimare cio che e successo da poco. Il bias di conferma porta a cercare solo numeri che confermano una convinzione gia formata. L illusione di controllo fa credere che un pattern visibile equivalga a una regola stabile. Le statistiche usate bene non eliminano questi bias da sole, ma offrono una struttura che li rende piu facili da riconoscere e correggere.</p>
              <p>Nel calcolo delle probabilita operative, il punto chiave non e predire "cosa uscira", ma valutare "quanto una lettura e affidabile". Questo cambia completamente la prospettiva: da una logica binaria (giusto/sbagliato) a una logica graduata (forte/intermedio/debole). In pratica, si passa dalla ricerca del numero "giusto" alla valutazione del rischio informativo associato a ogni scenario. E una differenza sottile, ma decisiva per prendere decisioni coerenti nel tempo.</p>
              <p>Un altro aspetto importante e la replicabilita. Una buona lettura statistica deve poter essere rifatta domani con nuovi dati, ottenendo conclusioni compatibili o spiegazioni chiare delle differenze. Se un risultato dipende solo da una scelta arbitraria di finestra o da un parametro nascosto, non e solido. Questo criterio di replicabilita protegge da entusiasmi improvvisi e rende l analisi molto piu disciplinata, soprattutto quando il dataset cresce e il rumore aumenta.</p>
              <p>In sintesi, le statistiche qui servono a organizzare il dubbio, non a vendere certezze. Ti danno un linguaggio comune per discutere ipotesi, confrontare scenari e misurare stabilita. La pagina sulle frequenze mostrer? come nasce la baseline. Quella sui ritardi aggiunge profondita temporale. Le co-occorrenze introducono la dimensione relazionale. La stabilita finale decide quanto il segnale merita fiducia. Ogni tab completa la precedente: e proprio questa continuita a rendere utile la lettura lunga.</p>
            </section>

            <section class="tab-panel space-y-4" data-tab-panel="frequenze">

              <h2 class="text-lg font-semibold text-white">Frequenze: base empirica del modello probabilistico</h2>
              <p>La frequenza e la metrica piu intuitiva: conta quante volte un evento compare in un certo periodo. Proprio per la sua semplicit?, e la prima lente da usare e anche la prima da trattare con cautela. Un numero visto spesso puo sembrare "caldo", ma il valore reale dipende da come hai definito la finestra, dal numero totale di concorsi inclusi e dalla varianza naturale del processo. Senza questi elementi, la frequenza resta un numero decorativo.</p>
              <p>Il passaggio decisivo e normalizzare: non guardare solo il conteggio assoluto, ma la frequenza relativa rispetto al campione e al comportamento medio. Una stessa conta puo avere significati diversi in periodi differenti. Quando la leggi in chiave relativa, la frequenza diventa comparabile e permette confronti piu corretti tra finestre brevi, medie e lunghe. Questo e il primo mattone per un calcolo probabilistico coerente.</p>
              <p>Dal punto di vista operativo, le frequenze costruiscono la baseline: cio che e ordinario, cio che e lievemente anomalo, cio che e veramente fuori scala. Ma la parola chiave e "baseline", non "previsione". Se una frequenza appare alta in una sola finestra e poi rientra, e probabile che sia fluttuazione locale. Se mantiene intensita su piu finestre indipendenti, il segnale diventa piu interessante, anche se resta sempre un segnale descrittivo, non predittivo in senso forte.</p>
              <p>Per rendere la metrica piu utile, conviene leggere insieme frequenza media, dispersione e posizione percentuale nel ranking storico. In questo modo non ti limiti a dire "e alto", ma puoi dire "quanto e alto rispetto alla sua storia". Questa differenza linguistica sembra minima, ma cambia il processo decisionale: si passa da impressione soggettiva a misura comparabile. E questa comparabilita che rende il modello aggiornabile nel tempo senza perdere coerenza.</p>
              <p>Un tema spesso sottovalutato e la sensibilita ai cambi di regime. Anche in sistemi casuali, la combinazione di rumore e campione finito puo creare fasi dove alcune frequenze sembrano dominanti. Se il modello non distingue tra trend stabile e fase rumorosa, la lettura si degrada rapidamente. Per questo la frequenza va sempre accompagnata da controlli temporali: non solo quanto, ma quando e con quale continuita.</p>
              <p>Nel calcolo probabilistico pratico, la frequenza aiuta soprattutto a filtrare priorita: dove approfondire, dove essere prudenti, dove evitare overfitting interpretativo. Non dice "succedera", ma aiuta a stimare quali scenari hanno maggiore coerenza storica. E qui entra la relazione con le tab successive: il ritardo aggiunge il fattore tempo, le co-occorrenze misurano le relazioni, la stabilita verifica se la storia regge quando cambia la lente.</p>
              <p>In conclusione, la frequenza funziona come bussola iniziale. Senza di lei il quadro e troppo dispersivo; con lei sola il quadro e incompleto. Il suo valore massimo emerge quando e integrata in una catena logica: baseline, conferme incrociate, robustezza. E proprio questa catena che rende la permanenza su tutte le tab utile e non ridondante: ogni passaggio riduce un tipo diverso di errore interpretativo.</p>
            </section>

            <section class="tab-panel space-y-4" data-tab-panel="ritardi">

              <h2 class="text-lg font-semibold text-white">Ritardi: distanza temporale e interpretazione corretta</h2>
              <p>Il ritardo misura la distanza dall ultima occorrenza di un evento. E una metrica potentissima sul piano percettivo: quando un numero manca a lungo, l attenzione cresce in modo naturale. Ma proprio qui nasce il rischio di interpretazione impulsiva. Un ritardo alto non e una garanzia di uscita imminente; e una descrizione temporale che va confrontata con la sua distribuzione storica. In altre parole, prima di trarre conclusioni devi capire se stai vedendo un anomalia reale o una coda normale.</p>
              <p>La domanda giusta non e "quando uscira", ma "quanto questo ritardo e raro rispetto al suo profilo tipico". Se il valore attuale supera soglie elevate in modo persistente, il dato diventa interessante come segnale di tensione statistica. Se oscilla vicino ai valori mediani, probabilmente non aggiunge informazione forte. Questo tipo di lettura evita il bias piu famoso: la convinzione che il sistema "debba compensare" nel breve termine.</p>
              <p>Per un uso serio del ritardo, serve confronto multiplo: percentile storico, velocita di crescita del ritardo, comportamento su finestre diverse e coerenza con le altre metriche. Se il ritardo e alto ma la frequenza recente e gia in recupero, la lettura cambia. Se il ritardo e alto e le co-occorrenze del gruppo sono deboli, cambia ancora. Quindi il ritardo non e un comando operativo: e un acceleratore di attenzione che va validato.</p>
              <p>C e poi un punto pratico spesso ignorato: non tutti i ritardi hanno lo stesso valore informativo. Alcuni numeri storicamente mostrano distribuzioni piu volatile, altri piu regolari. Usare una soglia unica per tutti crea distorsioni. Meglio stimare il ritardo in relazione al profilo specifico del numero e al contesto della finestra osservata. Questa personalizzazione aumenta la precisione descrittiva e riduce i falsi allarmi.</p>
              <p>Dal lato probabilistico, il ritardo contribuisce a definire il rischio di scenario. Non predice l evento, ma aiuta a classificare la pressione informativa: ordinaria, tesa, estrema. Questa classificazione e utile quando devi decidere quanto peso assegnare a una ipotesi dentro il modello complessivo. Se la pressione e alta ma gli altri indicatori non convergono, il segnale resta fragile. Se la pressione e alta e la convergenza cresce, il segnale guadagna credibilita operativa.</p>
              <p>Un buon modello usa il ritardo per porre domande migliori, non per chiuderle in fretta. Domande del tipo: questa anomalia e stabile? compare in piu finestre? e accompagnata da variazioni coerenti nelle frequenze? si riflette anche nelle relazioni tra numeri? Quando il ritardo viene inserito in questo flusso, smette di essere un trigger emotivo e diventa una variabile utile alla qualit? dell analisi.</p>
              <p>La tab successiva completa il quadro con le co-occorrenze, dove il focus non e piu il singolo numero ma le relazioni. E il passaggio naturale: dopo aver misurato "quanto manca", devi capire "con chi compare" quando torna nel sistema osservato.</p>
            </section>

            <section class="tab-panel space-y-4" data-tab-panel="cooccorrenze">

              <h2 class="text-lg font-semibold text-white">Co-occorrenze: coppie e gruppi oltre il caso apparente</h2>
              <p>Le co-occorrenze spostano l analisi dalla dimensione individuale a quella relazionale. Invece di chiederti quante volte esce un numero, ti chiedi quante volte certi numeri compaiono insieme e con quale intensita rispetto all atteso. Dal punto di vista probabilistico e un passaggio decisivo: entra in scena la probabilita congiunta. Questo amplia la potenza interpretativa ma aumenta anche il rischio di vedere pattern dove c e solo rumore.</p>
              <p>Quando il numero di combinazioni osservate cresce, cresce anche la probabilita di trovare relazioni apparentemente eccezionali per puro caso. E il motivo per cui le co-occorrenze richiedono piu controlli delle metriche semplici. Non basta "compare spesso": serve confrontare con una baseline teorica o empirica, verificare la persistenza su piu finestre, e controllare che il segnale non collassi appena vari i parametri principali.</p>
              <p>Un buon uso delle co-occorrenze parte da coppie e terzine stabili e poi valuta la coerenza con frequenze e ritardi. Se una relazione e alta ma i singoli componenti mostrano comportamenti incoerenti, il segnale potrebbe essere fragile. Se invece relazione e metriche di base convergono, allora la struttura diventa piu interessante. In pratica, la relazione non sostituisce il contesto: lo completa.</p>
              <p>Un aspetto avanzato riguarda la direzione temporale. Alcune co-occorrenze sono forti in una fase e deboli nella successiva. Questo non le rende inutili; indica che il segnale puo essere regime-dipendente. Per questo conviene monitorare la stabilita della relazione nel tempo, non solo il valore medio complessivo. Una relazione meno intensa ma persistente puo essere piu informativa di una relazione altissima ma effimera.</p>
              <p>Nel calcolo delle probabilita operative, le co-occorrenze aiutano a pesare configurazioni, non solo elementi singoli. Offrono un vantaggio concreto: riducono la visione atomica del dataset e permettono di ragionare per strutture. Ma chiedono disciplina: ogni segnale relazionale va testato contro il rischio di overfitting interpretativo. In assenza di test, l effetto narrativo vince sulla qualit? del modello.</p>
              <p>Quando questa metrica e ben integrata, migliora la selezione degli scenari candidati e la coerenza tra tab diverse. Ti dice dove il sistema sembra parlare "in combinazione", non solo in frequenza. Ed e qui che l ultima tab diventa fondamentale: la stabilita decide se il linguaggio trovato e durevole oppure solo un eco temporaneo del caso.</p>
              <p>Leggere le co-occorrenze con questa lente rende la pagina successiva quasi naturale: dopo aver visto relazioni forti, devi chiederti se restano forti quando il tempo passa e la finestra cambia.</p>
            </section>

            <section class="tab-panel space-y-4" data-tab-panel="stabilita">

              <h2 class="text-lg font-semibold text-white">Stabilita temporale, robustezza e gestione del rischio</h2>
              <p>La stabilita e il filtro finale che separa i segnali interessanti dai segnali affidabili. Un valore puo essere alto oggi e irrilevante domani: senza verifica temporale, questa differenza resta invisibile. La stabilita misura proprio questo: quanto un indicatore mantiene forma, direzione e intensita quando cambi finestra di osservazione. Se il segnale sopravvive a questo test, merita piu peso. Se collassa, va trattato come ipotesi fragile.</p>
              <p>In termini operativi, la stabilita evita di confondere intensita con robustezza. Un picco forte puo impressionare, ma una traccia moderata e persistente spesso e piu utile. Questo e un passaggio controintuitivo ma centrale: il modello non deve premiare solo "chi urla di piu", deve premiare chi regge nel tempo. In analisi probabilistica, continuita e coerenza valgono quanto il livello assoluto della metrica.</p>
              <p>Per leggere bene la stabilita, conviene costruire scenari: forte, intermedio, debole. Lo scenario forte combina convergenza multi-metrica e persistenza inter-finestra. Lo scenario intermedio mostra convergenza parziale o persistenza limitata. Lo scenario debole appare intenso ma disallineato o instabile. Questa classificazione semplifica le decisioni e riduce la dipendenza da intuizioni estemporanee.</p>
              <p>Un altro vantaggio della stabilita e la replicabilita. Se una lettura e robusta, dovrebbe rimanere comprensibile anche dopo aggiornamenti successivi del dataset. Non serve identita perfetta, serve coerenza di struttura: stesso tipo di segnale, stessa direzione di fondo, variazioni spiegabili. Quando questa condizione non c e, il modello deve ammetterlo apertamente: la trasparenza metodologica e parte della qualit?.</p>
              <p>La gestione del rischio nasce proprio qui. Ogni indicatore riceve un peso proporzionato a tre fattori: forza, coerenza, stabilita. Questo impedisce che una sola metrica domini la decisione. Invece di una lista di numeri "preferiti", ottieni una mappa di affidabilita progressiva. E una differenza sostanziale: non elimina l incertezza, ma la rende governabile e misurabile nel tempo.</p>
              <p>La conclusione e semplice ma potente: probabilita non significa promessa di esito, significa qualit? del processo decisionale sotto incertezza. Se un segnale dura, hai costruito conoscenza. Se si spegne, hai imparato un limite del modello. In entrambi i casi il metodo funziona, perche produce informazione utile e verificabile. E questo, piu di qualsiasi risultato singolo, e il vero obiettivo di una lettura statistica matura.</p>
              <p>Chiudendo il percorso delle tab, il messaggio resta coerente: nessuna metrica basta da sola, ma un sistema integrato puo migliorare nettamente il modo in cui interpreti i dati. E proprio questa integrazione che aumenta il tempo di lettura con valore reale, non per riempire spazio ma per costruire un ragionamento completo.</p>
            </section>

            <section class="tab-panel space-y-4" data-tab-panel="ranking">
              <div class="overflow-x-auto rounded-2xl border border-white/10">
                <table class="min-w-full text-left text-sm">
                  <thead class="bg-midnight/80 text-xs uppercase tracking-[0.2em] text-ash">
                    <tr>
                      <th class="px-4 py-3">Posizione</th>
                      <th class="px-4 py-3">Algoritmo</th>
                      <th class="px-4 py-3">Ranking</th>
                      <th class="px-4 py-3">Dettaglio</th>
                    </tr>
                  </thead>
                  <tbody class="divide-y divide-white/5" data-ranking-body>
                    <tr><td class="px-4 py-3 text-ash" colspan="4">Caricamento ranking...</td></tr>
                  </tbody>
                </table>
              </div>
            </section>

            <div class="mt-6 flex flex-wrap gap-3">
              <a class="rounded-full border border-neon/70 bg-neon/10 px-4 py-2 text-sm font-semibold text-neon transition hover:-translate-y-1 hover:bg-neon/20" href="../storico-estrazioni/">Apri archivio storico</a>
              <a class="rounded-full border border-white/20 bg-white/5 px-4 py-2 text-sm font-semibold text-white/90 transition hover:-translate-y-1 hover:border-neon/70 hover:text-neon" href="../algoritmi/index.html">Vai al catalogo algoritmi</a>
              <a class="rounded-full border border-white/20 bg-white/5 px-4 py-2 text-sm font-semibold text-white/90 transition hover:-translate-y-1 hover:border-neon/70 hover:text-neon" href="#top">Torna in alto</a>
            </div>
          </div>
        </div>
      </section>
    </div>
  </main>

  

  <script src="../../assets/js/version.js" defer></script>
  <script src="../../assets/js/header.js" defer></script>
  <script src="../../assets/js/ads.js" defer></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const PAYOUTS = { 0: 1.53, 1: 3.36, 2: 21.51, 3: 326.72, 4: 11906.95, 5: 1235346.49, 6: 622614630.0 };
      const roots = Array.from(document.querySelectorAll('[data-tabs-root]'));
      roots.forEach((root) => {
        const buttons = Array.from(root.querySelectorAll('[data-tab-target]'));
        const panels = Array.from(root.querySelectorAll('[data-tab-panel]'));
        const shell = root.classList.contains('tabs-shell') ? root : root.closest('.tabs-shell');
        const sheet = shell ? shell.querySelector('.tabs-sheet') : null;
        const tabRow = shell ? shell.querySelector('.folder-tabs') : null;
        if (!shell || !sheet || !tabRow) return;
        const showPanelLabel = root.dataset.tabPanelLabel !== 'off';
        const getLabelByTarget = (target) => {
          const button = buttons.find((btn) => btn.dataset.tabTarget === target);
          return button ? button.textContent.trim() : '';
        };
        const ensurePanelLabels = () => {
          if (!showPanelLabel) {
            panels.forEach((panel) => {
              panel.querySelectorAll(':scope > [data-tab-active-label]').forEach((label) => label.remove());
            });
            return;
          }
          panels.forEach((panel) => {
            let label = panel.querySelector(':scope > [data-tab-active-label]');
            if (!label) {
              label = document.createElement('p');
              label.className = 'tab-active-label';
              label.dataset.tabActiveLabel = '';
              label.setAttribute('aria-live', 'polite');
              panel.prepend(label);
            }
            label.textContent = getLabelByTarget(panel.dataset.tabPanel);
          });
        };

        const updateNotch = () => {
          const activeBtn = buttons.find((btn) => btn.classList.contains('is-active')) || buttons[0];
          if (!activeBtn) return;
          const rowRect = tabRow.getBoundingClientRect();
          const btnRect = activeBtn.getBoundingClientRect();
          const firstBtnRect = buttons[0]?.getBoundingClientRect();
          const left = Math.max(0, btnRect.left - rowRect.left);
          const width = Math.max(0, btnRect.width);
          const isWrapped = Boolean(firstBtnRect) && rowRect.height > (firstBtnRect.height + 6);
          const isOverflowing = tabRow.scrollWidth > (tabRow.clientWidth + 4);
          shell.classList.toggle('is-compact-tabs', isWrapped || isOverflowing);
          shell.style.setProperty('--active-notch-left', `${left.toFixed(2)}px`);
          shell.style.setProperty('--active-notch-width', `${width.toFixed(2)}px`);
        };

        const activate = (target) => {
          buttons.forEach((btn) => btn.classList.toggle('is-active', btn.dataset.tabTarget === target));
          panels.forEach((panel) => panel.classList.toggle('is-active', panel.dataset.tabPanel === target));
          updateNotch();
        };
        const refreshTabsLayout = () => window.requestAnimationFrame(updateNotch);

        buttons.forEach((btn) => {
          btn.addEventListener('click', () => activate(btn.dataset.tabTarget));
        });
        window.addEventListener('resize', refreshTabsLayout, { passive: true });
        window.addEventListener('orientationchange', refreshTabsLayout, { passive: true });
        window.addEventListener('pageshow', refreshTabsLayout, { passive: true });
        document.addEventListener('visibilitychange', refreshTabsLayout, { passive: true });
        if (window.visualViewport) {
          window.visualViewport.addEventListener('resize', refreshTabsLayout, { passive: true });
        }
        if ('ResizeObserver' in window) {
          const observer = new ResizeObserver(() => refreshTabsLayout());
          observer.observe(shell);
          observer.observe(tabRow);
          root._tabsResizeObserver = observer;
        }
        ensurePanelLabels();
        refreshTabsLayout();
        window.setTimeout(refreshTabsLayout, 80);
        window.setTimeout(refreshTabsLayout, 220);
      });

      const resolveWithBase = (path) => {
        const value = String(path || '');
        if (!value) return value;
        if (value.startsWith('#') || /^https?:\/\//i.test(value) || value.startsWith('file:')) return value;
        const base = window.CC_BASE?.url;
        if (!base) return value;
        const trimmed = value.startsWith('/') ? value.slice(1) : value.replace(/^\.\//, '');
        return new URL(trimmed, base).toString();
      };

      const formatRanking = (value) => new Intl.NumberFormat('it-IT', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(value);

      const parseCsvRows = (raw) => {
        const clean = (v) => {
          const s = String(v || '').trim();
          if (s.startsWith('"') && s.endsWith('"') && s.length >= 2) return s.slice(1, -1).replace(/""/g, '"').trim();
          return s;
        };
        const lines = String(raw || '')
          .split(/\r?\n/)
          .map((line) => line.trim())
          .filter((line) => line.length > 0 && !line.startsWith('#'));
        if (!lines.length) return [];
        const header = lines[0].split(',').map((x) => clean(x));
        return lines.slice(1).map((line) => {
          const cells = line.split(',').map((x) => clean(x));
          if (cells.length > header.length) {
            const merged = cells.slice(0, header.length - 1);
            merged.push(clean(cells.slice(header.length - 1).join(',')));
            return header.reduce((acc, h, i) => { acc[h] = merged[i] || ''; return acc; }, {});
          }
          return header.reduce((acc, h, i) => { acc[h] = cells[i] || ''; return acc; }, {});
        });
      };

      const exactFromMetrics = (rows) => {
        const counts = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0 };
        let hasAny = false;
        (rows || []).forEach((row) => {
          const metric = String(row['METRICA'] || '').trim().toLowerCase();
          const m = metric.match(/^con\s+([0-6])\s+hit$/);
          if (!m) return;
          const k = Number.parseInt(m[1], 10);
          const v = Number.parseInt(String(row['VALORE'] || '').replace(/[^\d-]/g, ''), 10);
          if (!Number.isFinite(v)) return;
          counts[k] = Math.max(0, v);
          hasAny = true;
        });
        return hasAny ? counts : null;
      };

      const exactFromHistorical = (rows) => {
        const counts = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0 };
        (rows || []).forEach((row) => {
          let h = 0;
          for (let i = 1; i <= 6; i += 1) {
            const val = String(row[`N${i}`] || '').trim();
            if (val.startsWith('[') && val.endsWith(']')) h += 1;
          }
          if (h >= 0 && h <= 6) counts[h] += 1;
        });
        return counts;
      };

      const rankingFromCounts = (counts) => {
        let total = 0;
        for (let k = 0; k <= 6; k += 1) total += (counts[k] || 0) * (PAYOUTS[k] || 0);
        return total;
      };

      const mergeExactCountsLikeCards = (metricsRows, historicalRows) => {
        const fromMetrics = exactFromMetrics(metricsRows);
        const fromHist = exactFromHistorical(historicalRows);
        if (fromMetrics) {
          // Keep exact 2..6 from metrics, derive 0/1 from historical (same logic used by cards).
          const out = { ...fromMetrics };
          out[0] = fromHist[0] || 0;
          out[1] = fromHist[1] || 0;
          return out;
        }
        return fromHist;
      };

      const fetchAlgorithmRanking = async (card) => {
        const page = String(card?.page || '');
        if (!page) return null;
        const base = /\.html?$/i.test(page) ? page.replace(/[^/]+$/i, '') : `${page.replace(/\/?$/, '/')}`;
        const metricsUrl = resolveWithBase(`${base}out/metrics-db.csv`);
        const historicalUrl = resolveWithBase(`${base}out/historical-db.csv`);
        try {
          const [mRes, hRes] = await Promise.all([fetch(metricsUrl, { cache: 'no-store' }), fetch(historicalUrl, { cache: 'no-store' })]);
          const metricsRows = mRes.ok ? parseCsvRows(await mRes.text()) : [];
          const historicalRows = hRes.ok ? parseCsvRows(await hRes.text()) : [];
          const exact = mergeExactCountsLikeCards(metricsRows, historicalRows);
          const ranking = rankingFromCounts(exact);
          return {
            title: String(card?.title || card?.id || 'Algoritmo'),
            ranking,
            hits: exact
          };
        } catch (_) {
          return null;
        }
      };

      const loadRanking = async () => {
        const tbody = document.querySelector('[data-ranking-body]');
        if (!tbody) return;
        try {
          const res = await fetch(resolveWithBase('data/modules-manifest.json'), { cache: 'no-store' });
          if (!res.ok) throw new Error(`status ${res.status}`);
          const manifest = await res.json();
          const cardPaths = Array.isArray(manifest) ? manifest.filter((x) => typeof x === 'string') : [];
          const cards = (await Promise.all(cardPaths.map(async (path) => {
            try {
              const cardRes = await fetch(resolveWithBase(path), { cache: 'no-store' });
              if (!cardRes.ok) return null;
              return await cardRes.json();
            } catch (_) {
              return null;
            }
          }))).filter(Boolean);
          const algs = cards.filter((x) => x?.isActive !== false && String(x?.page || '').includes('/algoritmi/algs/'));
          const rankedRaw = (await Promise.all(algs.map(fetchAlgorithmRanking))).filter(Boolean);
          const ranked = rankedRaw
            .map((row) => ({ ...row, _rank: Number.isFinite(row.ranking) ? row.ranking : Number.NEGATIVE_INFINITY }))
            .sort((a, b) => b._rank - a._rank);
          if (!ranked.length) {
            tbody.innerHTML = '<tr><td class="px-4 py-3 text-ash" colspan="4">Nessun algoritmo attivo con ranking disponibile.</td></tr>';
            return;
          }
          tbody.innerHTML = ranked.map((row, idx) => {
            const d = row.hits;
            const detail = `0:${d[0]} 1:${d[1]} 2:${d[2]} 3:${d[3]} 4:${d[4]} 5:${d[5]} 6:${d[6]}`;
            const rankingLabel = Number.isFinite(row.ranking) ? formatRanking(row.ranking) : 'N/D';
            return `<tr><td class="px-4 py-3 text-ash">${idx + 1}</td><td class="px-4 py-3 text-white">${row.title}</td><td class="px-4 py-3 text-white">${rankingLabel}</td><td class="px-4 py-3 text-ash">${detail}</td></tr>`;
          }).join('');
        } catch (_) {
          tbody.innerHTML = '<tr><td class="px-4 py-3 text-ash" colspan="4">Impossibile caricare il ranking algoritmi.</td></tr>';
        }
      };

      loadRanking();
    });
  </script>
</body>
</html>











